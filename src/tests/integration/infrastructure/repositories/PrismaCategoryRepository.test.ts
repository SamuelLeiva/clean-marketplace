import { describe, it, expect, beforeEach, afterAll } from 'vitest';
import { PrismaClient } from '@prisma/client';
import { PrismaCategoryRepository } from '@/infrastructure/database/prisma/repositories'; // Adjust path as necessary
//import { Category } from '@/core/entities'; // Adjust path as necessary
import { CreateCategoryInput, UpdateCategoryInput } from '@/shared/contracts'; // Adjust path as necessary

// We'll use a local PrismaClient instance for testing purposes
// It will pick up the DATABASE_URL from your environment (e.g., .env.test)
const prisma = new PrismaClient();

describe('PrismaCategoryRepository (Integration Tests)', () => {
  let repository: PrismaCategoryRepository;

  // IMPORTANT: The `beforeEach` in `vitest.setup.ts` should already handle
  // clearing the database. If you're not using `vitest.setup.ts`, uncomment
  // the direct `beforeEach` block below to clear the database.
  /*
  beforeEach(async () => {
    await prisma.category.deleteMany({});
  });
  */

  beforeEach(() => {
    // Initialize the repository before each test
    repository = new PrismaCategoryRepository();
  });

  // Ensure the PrismaClient disconnects after all tests are done
  // This is also typically handled in `vitest.setup.ts`
  afterAll(async () => {
    await prisma.$disconnect();
  });

  // --- Test Data ---
  const dummyCategoryInput: CreateCategoryInput = {
    name: 'Electronics',
    description: 'Devices and gadgets.',
  };

  const anotherCategoryInput: CreateCategoryInput = {
    name: 'Books',
    description: 'Fiction and non-fiction.',
  };

  const categoryInputWithoutDescription: CreateCategoryInput = {
    name: 'Software',
    // Description is optional, so we omit it here
  };

  // --- Test Cases ---

  describe('create', () => {
    it('should create a new category in the database', async () => {
      const createdCategory = await repository.create(dummyCategoryInput);

      expect(createdCategory).toBeDefined();
      expect(createdCategory.id).toBeDefined(); // ID should be generated by Prisma
      expect(createdCategory.name).toBe(dummyCategoryInput.name);
      expect(createdCategory.description).toBe(dummyCategoryInput.description);
      expect(createdCategory.createdAt).toBeDefined();
      expect(createdCategory.updatedAt).toBeDefined();

      // Verify by fetching directly from the database
      const foundInDb = await prisma.category.findUnique({
        where: { id: createdCategory.id },
      });
      expect(foundInDb).not.toBeNull();
      expect(foundInDb?.name).toBe(dummyCategoryInput.name);
      expect(foundInDb?.description).toBe(dummyCategoryInput.description);
    });

    it('should correctly store a category with an omitted (undefined) description', async () => {
      const createdCategory = await repository.create(categoryInputWithoutDescription);

      expect(createdCategory).toBeDefined();
      expect(createdCategory.id).toBeDefined();
      expect(createdCategory.name).toBe(categoryInputWithoutDescription.name);
      // Prisma stores omitted string fields as null by default when `normalizeCategory` is applied
      expect(createdCategory.description).toBeUndefined(); // Assuming normalizeCategory maps null to undefined

      // Verify directly from the database
      const foundInDb = await prisma.category.findUnique({
        where: { id: createdCategory.id },
      });
      expect(foundInDb?.description).toBeNull(); // Prisma's default is null for omitted string
    });
  });

  describe('findAll', () => {
    it('should return an empty array if no categories exist', async () => {
      const categories = await repository.findAll();
      expect(categories).toEqual([]);
      expect(categories.length).toBe(0);
    });

    it('should return all categories in the database', async () => {
      // Create multiple categories directly using Prisma for setup
      await prisma.category.createMany({
        data: [dummyCategoryInput, anotherCategoryInput],
      });

      const categories = await repository.findAll();

      expect(categories).toBeDefined();
      expect(categories.length).toBe(2);
      expect(categories.some(c => c.name === dummyCategoryInput.name)).toBe(true);
      expect(categories.some(c => c.name === anotherCategoryInput.name)).toBe(true);
    });
  });

  describe('findById', () => {
    it('should return null if no category with the given ID exists', async () => {
      const category = await repository.findById('non-existent-id');
      expect(category).toBeNull();
    });

    it('should return the category if found by ID', async () => {
      // Create a category directly using Prisma for setup
      const created = await prisma.category.create({ data: dummyCategoryInput });

      const foundCategory = await repository.findById(created.id);

      expect(foundCategory).not.toBeNull();
      expect(foundCategory?.id).toBe(created.id);
      expect(foundCategory?.name).toBe(dummyCategoryInput.name);
    });
  });

  describe('update', () => {
    it('should update an existing category with new data', async () => {
      // Create a category to update
      const categoryToUpdate = await prisma.category.create({ data: dummyCategoryInput });

      const updateInput: UpdateCategoryInput = {
        name: 'Updated Category Name',
        description: 'Updated description.',
      };

      const updatedCategory = await repository.update(categoryToUpdate.id, updateInput);

      expect(updatedCategory).toBeDefined();
      expect(updatedCategory.id).toBe(categoryToUpdate.id);
      expect(updatedCategory.name).toBe(updateInput.name);
      expect(updatedCategory.description).toBe(updateInput.description);
      expect(updatedCategory.updatedAt).not.toBe(categoryToUpdate.updatedAt); // Should be updated

      // Verify directly from the database
      const foundInDb = await prisma.category.findUnique({
        where: { id: categoryToUpdate.id },
      });
      expect(foundInDb?.name).toBe(updateInput.name);
      expect(foundInDb?.description).toBe(updateInput.description);
    });

    it('should allow setting an optional field (description) to undefined (null in DB)', async () => {
      // Create a category with a description
      const categoryWithDesc = await prisma.category.create({
        data: {
          ...dummyCategoryInput,
          name: 'Category With Description', // Unique name
          description: 'Original description here.',
        },
      });

      const updateInput: UpdateCategoryInput = {
        description: null, // Explicitly setting to undefined in input
      };

      const updatedCategory = await repository.update(categoryWithDesc.id, updateInput);

      expect(updatedCategory.description).toBeUndefined(); // Should be undefined after normalizeCategory

      const foundInDb = await prisma.category.findUnique({
        where: { id: categoryWithDesc.id },
      });
      expect(foundInDb?.description).toBeNull(); // Prisma stores it as null
    });

    it('should throw an error if trying to update a non-existent category', async () => {
      const nonExistentId = 'non-existent-update-id';
      const updateInput: UpdateCategoryInput = { name: 'Attempted Update' };

      // Prisma's `update` method throws `P2025` for RecordNotFound if it doesn't find the record.
      await expect(repository.update(nonExistentId, updateInput)).rejects.toThrow();
      // Optionally, you can assert on the specific Prisma error code:
      // expect(error.code).toBe('P2025');
    });
  });

  describe('delete', () => {
    it('should delete a category from the database', async () => {
      // Create a category to delete
      const categoryToDelete = await prisma.category.create({ data: dummyCategoryInput });

      await repository.delete(categoryToDelete.id);

      // Verify directly from the database
      const foundInDb = await prisma.category.findUnique({
        where: { id: categoryToDelete.id },
      });
      expect(foundInDb).toBeNull();
    });

    it('should throw an error if trying to delete a non-existent category', async () => {
      const nonExistentId = 'non-existent-delete-id';
      // Prisma's `delete` method directly throws if the `where` clause finds no record.
      await expect(repository.delete(nonExistentId)).rejects.toThrow();
      // expect(error.code).toBe('P2025');
    });
  });

  describe('findByName', () => {
    it('should return null if no category with the given name exists', async () => {
      const category = await repository.findByName('Non Existent Name');
      expect(category).toBeNull();
    });

    it('should return the category if found by name', async () => {
      // Create a category directly using Prisma for setup
      const created = await prisma.category.create({ data: dummyCategoryInput });

      const foundCategory = await repository.findByName(dummyCategoryInput.name);

      expect(foundCategory).not.toBeNull();
      expect(foundCategory?.id).toBe(created.id);
      expect(foundCategory?.name).toBe(dummyCategoryInput.name);
    });
  });

  describe('isInUse', () => {
    it('should always return false temporarily as per current implementation', async () => {
      // Create a category just to have an ID, although it's not used in the current isInUse logic
      const category = await prisma.category.create({ data: dummyCategoryInput });

      const inUseStatus = await repository.isInUse(category.id);
      expect(inUseStatus).toBe(false);

      // Test with a non-existent ID as well, still expecting false
      const inUseStatusNonExistent = await repository.isInUse('random-non-existent-id');
      expect(inUseStatusNonExistent).toBe(false);
    });
  });
});